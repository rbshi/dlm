package hwsys.util

import spinal.core._
import spinal.lib._


/** Implicit helpers */
object Helpers {
  implicit class StreamUtils[T <: Data](stream: Stream[T]) {

    def fmap[T2 <: Data](f: T => T2): Stream[T2] = {
      stream ~~ f
    }

    /** Fire the stream with a token generated by `tokenSig`, e.g., fire the FIFO.io.pop once axi.b.fire
     */
    def continueWithToken(tokenAdd: Bool, maxTokenCnt: Int): Stream[T] = {
      val cntToken = Reg(UInt(log2Up(maxTokenCnt) + 1 bits)).init(0)
      switch(tokenAdd ## stream.fire) {
        is(True ## False)(cntToken := cntToken + 1)
        is(False ## True)(cntToken := cntToken - 1)
        default()
      }
      stream.continueWhen(cntToken > 0)
    }

    def continueWithToken(tokenAdd: Bool, tokenMinus: Bool, maxTokenCnt: Int): Stream[T] = {
      val cntToken = Reg(UInt(log2Up(maxTokenCnt) + 1 bits)).init(0)
      switch(tokenAdd ## tokenMinus) {
        is(True ## False)(cntToken := cntToken + 1)
        is(False ## True)(cntToken := cntToken - 1)
        default()
      }
      stream.continueWhen(cntToken > 0)
    }

    /** Fork2 the stream to Streams(T1, T2) if cond is True, otherwise bypass the stream -> stream1 and idle the stream2
     */
    def conditionFork2[T1 <: Data, T2 <: Data](cond: Bool, stream1: Stream[T1], stream2: Stream[T2]): Unit = {
      // payload of stream1/2 should be assigned outside
      when(~cond) {
        // bypass the stream -> stream1 with f1
        stream1.arbitrationFrom(stream)
        stream2.valid := False
      } otherwise {
        val (strmFork1, strmFork2) = StreamFork2(stream, synchronous = false)
        stream1.arbitrationFrom(strmFork1)
        stream2.arbitrationFrom(strmFork2)
      }
    }

    def tieOff(isOutSide: Boolean = true): Unit ={
      isOutSide match {
        case true => if(stream.isMasterInterface) stream.setBlocked() else stream.setIdle()
        case false => if(stream.isMasterInterface) stream.setIdle() else stream.setBlocked()
      }
    }

  }
}



















