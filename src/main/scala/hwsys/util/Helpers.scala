package hwsys.util

import spinal.core._
import spinal.lib._
import spinal.lib.bus.amba4.axilite._

/** Implicit helpers */
object Helpers {
  implicit class StreamUtils[T <: Data](stream: Stream[T]) {

    def fmap[T2 <: Data](f: T => T2): Stream[T2] = {
      stream ~~ f
    }

    /** Fire the stream with a token generated by `tokenSig`, e.g., fire the FIFO.io.pop once axi.b.fire
     */
    def continueWithToken(tokenAdd: Bool, maxTokenCnt: Int): Stream[T] = {
      val cntToken = Reg(UInt(log2Up(maxTokenCnt) + 1 bits)).init(0)
      switch(tokenAdd ## stream.fire) {
        is(True ## False)(cntToken := cntToken + 1)
        is(False ## True)(cntToken := cntToken - 1)
        default()
      }
      stream.continueWhen(cntToken > 0)
    }

    def continueWithToken(tokenAdd: Bool, tokenMinus: Bool, maxTokenCnt: Int): Stream[T] = {
      val cntToken = Reg(UInt(log2Up(maxTokenCnt) + 1 bits)).init(0)
      switch(tokenAdd ## tokenMinus) {
        is(True ## False)(cntToken := cntToken + 1)
        is(False ## True)(cntToken := cntToken - 1)
        default()
      }
      stream.continueWhen(cntToken > 0)
    }

    /** Fork2 the stream to Streams(T1, T2) if cond is True, otherwise bypass the stream -> stream1 and idle the stream2
     */
    def conditionFork2[T1 <: Data, T2 <: Data](cond: Bool, stream1: Stream[T1], stream2: Stream[T2]): Unit = {
      // payload of stream1/2 should be assigned outside
      when(~cond) {
        // bypass the stream -> stream1 with f1
        stream1.arbitrationFrom(stream)
        stream2.valid := False
      } otherwise {
        val (strmFork1, strmFork2) = StreamFork2(stream, synchronous = false)
        stream1.arbitrationFrom(strmFork1)
        stream2.arbitrationFrom(strmFork2)
      }
    }

    def tieOff(isOutSide: Boolean = true): Unit ={
      isOutSide match {
        case true => if(stream.isMasterInterface) stream.setBlocked() else stream.setIdle()
        case false => if(stream.isMasterInterface) stream.setIdle() else stream.setBlocked()
      }
    }

    def flipDir(): Unit = {
      if(stream.isMasterInterface)
        stream.asSlave()
      else
        stream.asMaster()
    }

  }


  implicit class BundleUtils(bd: Bundle) {

    /** AutoConnect the bundle with an other bundle by name */
    def connectAllByName(that: Bundle): Unit = {
      for ((name, element) <- bd.elements) {
        val other = that.find(name)
        if (other == null)
          LocatedPendingError(s"Bundle assignment is not complete. Missing $name")
        else
          element <> other // NOTE: no recursive is required -> bundle has autoConnect
      }
    }

    /** AutoConnect all possible signal of the bundle with an other bundle by name */
    def connectSomeByName(that: Bundle): Unit = {
      for ((name, element) <- bd.elements) {
        val other = that.find(name)
        if (other != null)
          element <> other
      }
    }

      // type issue
//    def tieOffB[T <: Data](isOutSide: Boolean = true): Unit = {
//      for ((name, element) <- bd.elements) {
//        element match {
//
//          case s: Stream[Data] => s.tieOff()
//          case b: Bundle => b.tieOffB(isOutSide)
//          case d: BaseType => if((isOutSide && d.isInput) || (!isOutSide && d.isOutput)) d.assignDontCare()
//          case vb: Vec[BaseType] => if((isOutSide && vb.isInput) || (!isOutSide && vb.isOutput)) vb.assignDontCare()
//          case vbun: Vec[Bundle] => vbun.foreach(_.tieOff())
//          case vstrm: Vec[Stream[Data]] => vstrm.foreach(_.tieOff())
//          case _ => LocatedPendingError(s"tieOff behavior of $name is NOT defined.")
//        }
//      }
//    }


  }

  implicit class StreamFifoUtils[T <: Data](streamFifo: StreamFifo[T]) {
    def flushWhen(enFlush: Bool): Unit = {
      streamFifo.io.flush := enFlush
    }
  }

  implicit class AxiLite4SlaveFactoryUtils(ctrlR: AxiLite4SlaveFactory) {
    def rwInPort[T <: BaseType](inD: T, addr: BigInt, bitOffset: Int = 0, doc: String = null): T = {
      // require(inD.isInput || inD.isInOut)
      // require(inD.getBitsWidth < ctrlR.busDataWidth)
      val r = ctrlR.createReadAndWrite(inD, addr, bitOffset, doc)
      inD := r
      r
    }

    def getAddr(offset: Int)(implicit baseReg: Int): BigInt = {
      (baseReg + offset) << log2Up(ctrlR.busDataWidth/8)
    }


  }

//  implicit class RegUtils(value: BaseType) {
//    def inc()
//  }


}





















